\clearpage % Rozdziały zaczynamy od nowej strony.
\section{Specyfikacja wymagań i decyzje projektowe} 

W tym rozdziale zostały zdefiniowane wymagania opisujące system do rozpoznawania celu podszycia stron phishingowych.
Zostały one podzielone na dwie kategorie: wymagania funkcjonalne oraz niefunkcjonalne. 
Pierwsza z nich opisuje funkcjonalności, które system musi spełaniać definiując swoje zachowania, interakcje między nimi. 
Druga kategoria opisuje wymagania jakościowe, które system musi spełniać. 
Są to między innymi wymagania związane z wydajnością, czy jakością takowego systemu.

\subsection{Wymagania funkcjonalne}
\begin{itemize}
    \item system obsluguje zapytania za pomocą API (ang. \emph{Application Programming Interface})
    \item system zwraca odpowiedź w formacie JSON (ang. \emph{JavaScript Object Notation})
    \item system przyjmuje obraz (zrzut ekranu strony internetowej) oraz adres URL (ang. \emph{unifrom resource locator}) jako dane wejściowe
    \item system zwraca informacje o prawdopodobieństwie (pewności), że obraz przedstawia stronę phishingową
    \item system zwraca informacje o celu podszycia strony phishingowej
\end{itemize}
\subsection{Wymagania niefunkcjonalne}
\begin{itemize}    
    \item system zwraca odpowiedź w czasie krótszym niż 10 sekund
    \item system jest skonteneryzowany w oparciu o Docker
    \item system jest modularny tak by umożliwić dołożenie nowych metod klasyfikacji
    \item system jest napisany w języku Python
    \item system może być dowolnym zbiorem danych
\end{itemize}

\subsection{Architektura}
TODO: opisać diagramy
System składa się z trzech głównych modułów: API, klasyfikatora oraz baz danych.
\begin{figure}[!h]
    % Wyrównanie obrazka, szerokość i plik
    % Zamiast width można też użyć height, etc.
    \centering \includegraphics[width=0.5\linewidth]{System2.pdf}
    % Podpis umieszczamy pod obrazkiem
    % znacznik \caption służy również do wygenerowania numeru obrazka
    \caption{Diagram systemu}
    % \label pozwala odwołać się do obrazka w innych miejscach za pomocą \ref
    % odwołanie \ref renderuje się jako numer obrazka,
    % dlatego zawsze najpierw używaj \caption a potem \label
    \label{fig:diagram-systemu}
\end{figure}

% Przykładowy obrazek
\begin{figure}[!h]
    % Wyrównanie obrazka, szerokość i plik
    % Zamiast width można też użyć height, etc.
    \centering \includegraphics[width=1\linewidth]{Klasyfikator2.pdf}
    % Podpis umieszczamy pod obrazkiem
    % znacznik \caption służy również do wygenerowania numeru obrazka
    \caption{Diagram klasyfikatora}
    % \label pozwala odwołać się do obrazka w innych miejscach za pomocą \ref
    % odwołanie \ref renderuje się jako numer obrazka,
    % dlatego zawsze najpierw używaj \caption a potem \label
    \label{fig:diagram-klasyfikatora}
\end{figure}

\it{Każda metoda będzie implementować interfejs odpowiedzialny za wczytanie danych i zapisanie wyniku. Dodatkowo będzie to oddzielny kontener}

\subsection{Decyzje projektowe}
TODO: uzasadnić wybór
Traktowanie modeli jako blackbox -> phish +1 klasa (benign) (najłatwiej tak uogólnić wyniki)

\subsubsection{Wybór rozwiązań}
TODO: uzasadnić wybór
Python, 
FastAPI,
Pytorch, Tensorflow
Scikit learn
MongoDB,
MinIO

% % Fragment kodu źródłowego programu
% % \addmargin pozwala na wcięcie kodu od lewej (tu: 8mm).
% % Wcięcie służy do tego, aby numery linii nie wystawały poza lewy margines.
% % Druga liczba oznacza wcięcie od prawej.
% \begin{addmargin}[8mm]{0mm}
% \begin{lstlisting}[
%     language=HTML,
%     numbers=left,
%     firstnumber=1,
%     caption={\emph{Hello world} w HTML},
%     aboveskip=10pt
% ]
% <html>
%   <head>
%     <title>Hello world!</title>
%   </head>
%   <body>
%     Hello world!
%   </body>
% </html>
% \end{lstlisting}
% \end{addmargin}

% \lipsum[11]

% % Dla dłuższych numerów linii potrzebne jest większe wcięcie.
% \begin{addmargin}[12mm]{0mm}
% \begin{lstlisting}[
%     language=C++,
%     numbers=left,
%     firstnumber=147,
%     caption={Generowanie sekwencji Collatza w języku C++},
%     aboveskip=10pt
% ]
% class Collatz {
%   private:
%     unsigned current_val_;
%     void update_val() {
%         if( current_val_ % 2 == 0 )
%             current_val_ /= 2;
%         else
%             current_val_ = current_val_ * 3 + 1;
%     }

%   public:
%     explicit Collatz(unsigned initial_value) :
%         current_val_(initial_value) {}
%     void print_sequence() {
%         unsigned i = 1;
%         while( current_val_ > 1 ) {
%             std::cout
%                 << "val " << i << " = " << current_val_
%                 << std::endl;
%             update_val(); ++i;
%         }
%     }
% };

% int main() {
%   // prints Collatz seqence, starting from 194375
%   Collatz seq(194375);
%   seq.print_sequence();
%   return 0;
% }
% \end{lstlisting}
% \end{addmargin}

% \lipsum[12]